<!DOCTYPE html>
<html lang="en">
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dotgrid</title>
  </head>
  <body>
    <script>
'use strict'
function Acels (client) {
  this.el = document.createElement('ul')
  this.el.id = 'acels'
  this.order = []
  this.all = {}
  this.pipe = null
  this.install = (host = document.body) => {
    window.addEventListener('keydown', this.onKeyDown, false)
    window.addEventListener('keyup', this.onKeyUp, false)
    host.appendChild(this.el)
  }
  this.start = () => {
    const cats = this.sort()
    for (const cat of this.order) {
      const main = document.createElement('li')
      const head = document.createElement('a')
      head.innerText = cat
      const subs = document.createElement('ul')
      for (const item of cats[cat]) {
        const option = document.createElement('li')
        option.onclick = item.downfn
        option.innerHTML = item.accelerator ? `${item.name} <i>${item.accelerator.replace('CmdOrCtrl+', '^')}</i>` : `${item.name}`
        subs.appendChild(option)
      }
      main.appendChild(head)
      main.appendChild(subs)
      this.el.appendChild(main)
    }
  }
  this.set = (cat, name, accelerator, downfn, upfn) => {
    if (this.all[accelerator]) { console.warn('Acels', `Trying to overwrite ${this.all[accelerator].name}, with ${name}.`) }
    if (this.order.indexOf(cat) < 0) { this.order.push(cat) }
    this.all[accelerator] = { cat, name, downfn, upfn, accelerator }
  }
  this.get = (accelerator) => {
    return this.all[accelerator]
  }
  this.sort = () => {
    const h = {}
    for (const item of Object.values(this.all)) {
      if (!h[item.cat]) { h[item.cat] = [] }
      h[item.cat].push(item)
    }
    return h
  }
  this.convert = (event) => {
    const accelerator = event.key === ' ' ? 'Space' : capitalize(event.key.replace('Arrow', ''))
    if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
      return `CmdOrCtrl+Shift+${accelerator}`
    }
    if (event.shiftKey && event.key.toUpperCase() !== event.key) {
      return `Shift+${accelerator}`
    }
    if (event.altKey && event.key.length !== 1) {
      return `Alt+${accelerator}`
    }
    if (event.ctrlKey || event.metaKey) {
      return `CmdOrCtrl+${accelerator}`
    }
    return accelerator
  }
  this.route = (obj) => {
    this.pipe = obj
  }
  this.onKeyDown = (e) => {
    const target = this.get(this.convert(e))
    if (!target || !target.downfn) { return this.pipe ? this.pipe.onKeyDown(e) : null }
    target.downfn()
    e.preventDefault()
  }
  this.onKeyUp = (e) => {
    const target = this.get(this.convert(e))
    if (!target || !target.upfn) { return this.pipe ? this.pipe.onKeyUp(e) : null }
    target.upfn()
    e.preventDefault()
  }
  this.toMarkdown = () => {
    const cats = this.sort()
    let text = ''
    for (const cat in cats) {
      text += `\n### ${cat}\n\n`
      for (const item of cats[cat]) {
        text += item.accelerator ? `- \`${item.accelerator}\`: ${item.name}\n` : ''
      }
    }
    return text.trim()
  }
  this.toString = () => {
    const cats = this.sort()
    let text = ''
    for (const cat of this.order) {
      for (const item of cats[cat]) {
        text += item.accelerator ? `${cat.padEnd(8, ' ')} ${item.name.padEnd(16, ' ')} ${item.accelerator.replace('CmdOrCtrl+', '^')}\n` : ''
      }
    }
    return text.trim()
  }
  this.toggle = () => {
    this.el.className = this.el.className === 'hidden' ? '' : 'hidden'
  }
  function capitalize (s) { return s.substr(0, 1).toUpperCase() + s.substr(1) }
}
'use strict'
function History () {
  this.index = 0
  this.a = []
  this.clear = function () {
    this.a = []
    this.index = 0
  }
  this.push = function (data) {
    if (this.index < this.a.length - 1) {
      this.fork()
    }
    this.index = this.a.length
    this.a = this.a.slice(0, this.index)
    this.a.push(copy(data))
    if (this.a.length > 20) {
      this.a.shift()
    }
  }
  this.fork = function () {
    this.a = this.a.slice(0, this.index + 1)
  }
  this.pop = function () {
    return this.a.pop()
  }
  this.prev = function () {
    this.index = clamp(this.index - 1, 0, this.a.length - 1)
    return copy(this.a[this.index])
  }
  this.next = function () {
    this.index = clamp(this.index + 1, 0, this.a.length - 1)
    return copy(this.a[this.index])
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
'use strict'
function Source (client) {
  this.cache = {}
  this.install = () => {
  }
  this.start = () => {
    this.new()
  }
  this.new = () => {
    console.log('Source', 'New file..')
    this.cache = {}
  }
  this.open = (ext, callback, store = false) => {
    console.log('Source', 'Open file..')
    const input = document.createElement('input')
    input.type = 'file'
    input.onchange = (e) => {
      const file = e.target.files[0]
      if (file.name.indexOf('.' + ext) < 0) { console.warn('Source', `Skipped ${file.name}`); return }
      this.read(file, callback, store)
    }
    input.click()
  }
  this.load = (ext, callback) => {
    console.log('Source', 'Load files..')
    const input = document.createElement('input')
    input.type = 'file'
    input.setAttribute('multiple', 'multiple')
    input.onchange = (e) => {
      for (const file of e.target.files) {
        if (file.name.indexOf('.' + ext) < 0) { console.warn('Source', `Skipped ${file.name}`); continue }
        this.read(file, this.store)
      }
    }
    input.click()
  }
  this.store = (file, content) => {
    console.info('Source', 'Stored ' + file.name)
    this.cache[file.name] = content
  }
  this.save = (name, content, type = 'text/plain', callback) => {
    this.saveAs(name, content, type, callback)
  }
  this.saveAs = (name, ext, content, type = 'text/plain', callback) => {
    console.log('Source', 'Save new file..')
    this.write(name, ext, content, type, callback)
  }
  this.read = (file, callback, store = false) => {
    const reader = new FileReader()
    reader.onload = (event) => {
      const res = event.target.result
      if (callback) { callback(file, res) }
      if (store) { this.store(file, res) }
    }
    reader.readAsText(file, 'UTF-8')
  }
  this.write = (name, ext, content, type, settings = 'charset=utf-8') => {
    const link = document.createElement('a')
    link.setAttribute('download', `${name}-${timestamp()}.${ext}`)
    if (type === 'image/png' || type === 'image/jpeg') {
      link.setAttribute('href', content)
    } else {
      link.setAttribute('href', 'data:' + type + ';' + settings + ',' + encodeURIComponent(content))
    }
    link.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }))
  }
  function timestamp (d = new Date(), e = new Date(d)) {
    return `${arvelie()}-${neralie()}`
  }
  function arvelie (date = new Date()) {
    const start = new Date(date.getFullYear(), 0, 0)
    const diff = (date - start) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000)
    const doty = Math.floor(diff / 86400000) - 1
    const y = date.getFullYear().toString().substr(2, 2)
    const m = doty === 364 || doty === 365 ? '+' : String.fromCharCode(97 + Math.floor(doty / 14)).toUpperCase()
    const d = `${(doty === 365 ? 1 : doty === 366 ? 2 : (doty % 14)) + 1}`.padStart(2, '0')
    return `${y}${m}${d}`
  }
  function neralie (d = new Date(), e = new Date(d)) {
    const ms = e - d.setHours(0, 0, 0, 0)
    return (ms / 8640 / 10000).toFixed(6).substr(2, 6)
  }
}
'use strict'
function Theme (client) {
  this.el = document.createElement('style')
  this.el.type = 'text/css'
  this.active = {}
  this.default = {
    background: '#eeeeee',
    f_high: '#0a0a0a',
    f_med: '#4a4a4a',
    f_low: '#6a6a6a',
    f_inv: '#111111',
    b_high: '#a1a1a1',
    b_med: '#c1c1c1',
    b_low: '#ffffff',
    b_inv: '#ffb545'
  }
  this.onLoad = () => {}
  this.install = (host = document.body) => {
    window.addEventListener('dragover', this.drag)
    window.addEventListener('drop', this.drop)
    host.appendChild(this.el)
  }
  this.start = () => {
    console.log('Theme', 'Starting..')
    if (isJson(localStorage.theme)) {
      const storage = JSON.parse(localStorage.theme)
      if (isValid(storage)) {
        console.log('Theme', 'Loading theme in localStorage..')
        this.load(storage)
        return
      }
    }
    this.load(this.default)
  }
  this.open = () => {
    console.log('Theme', 'Open theme..')
    const input = document.createElement('input')
    input.type = 'file'
    input.onchange = (e) => {
      this.read(e.target.files[0], this.load)
    }
    input.click()
  }
  this.load = (data) => {
    const theme = this.parse(data)
    if (!isValid(theme)) { console.warn('Theme', 'Invalid format'); return }
    console.log('Theme', 'Loaded theme!')
    this.el.innerHTML = `:root { 
      --background: ${theme.background}; 
      --f_high: ${theme.f_high}; 
      --f_med: ${theme.f_med}; 
      --f_low: ${theme.f_low}; 
      --f_inv: ${theme.f_inv}; 
      --b_high: ${theme.b_high}; 
      --b_med: ${theme.b_med}; 
      --b_low: ${theme.b_low}; 
      --b_inv: ${theme.b_inv};
    }`
    localStorage.setItem('theme', JSON.stringify(theme))
    this.active = theme
    if (this.onLoad) {
      this.onLoad(data)
    }
  }
  this.reset = () => {
    this.load(this.default)
  }
  this.set = (key, val) => {
    if (!val) { return }
    const hex = (`${val}`.substr(0, 1) !== '#' ? '#' : '') + `${val}`
    if (!isColor(hex)) { console.warn('Theme', `${hex} is not a valid color.`); return }
    this.active[key] = hex
  }
  this.get = (key) => {
    return this.active[key]
  }
  this.parse = (any) => {
    if (isValid(any)) { return any }
    if (isJson(any)) { return JSON.parse(any) }
    if (isHtml(any)) { return extract(any) }
  }
  this.drag = (e) => {
    e.stopPropagation()
    e.preventDefault()
    e.dataTransfer.dropEffect = 'copy'
  }
  this.drop = (e) => {
    e.preventDefault()
    const file = e.dataTransfer.files[0]
    if (file.name.indexOf('.svg') > -1) {
      this.read(file, this.load)
    }
    e.stopPropagation()
  }
  this.read = (file, callback) => {
    const reader = new FileReader()
    reader.onload = (event) => {
      callback(event.target.result)
    }
    reader.readAsText(file, 'UTF-8')
  }
  function extract (xml) {
    const svg = new DOMParser().parseFromString(xml, 'text/xml')
    try {
      return {
        background: svg.getElementById('background').getAttribute('fill'),
        f_high: svg.getElementById('f_high').getAttribute('fill'),
        f_med: svg.getElementById('f_med').getAttribute('fill'),
        f_low: svg.getElementById('f_low').getAttribute('fill'),
        f_inv: svg.getElementById('f_inv').getAttribute('fill'),
        b_high: svg.getElementById('b_high').getAttribute('fill'),
        b_med: svg.getElementById('b_med').getAttribute('fill'),
        b_low: svg.getElementById('b_low').getAttribute('fill'),
        b_inv: svg.getElementById('b_inv').getAttribute('fill')
      }
    } catch (err) {
      console.warn('Theme', 'Incomplete SVG Theme', err)
    }
  }
  function isValid (json) {
    if (!json) { return false }
    if (!json.background || !isColor(json.background)) { return false }
    if (!json.f_high || !isColor(json.f_high)) { return false }
    if (!json.f_med || !isColor(json.f_med)) { return false }
    if (!json.f_low || !isColor(json.f_low)) { return false }
    if (!json.f_inv || !isColor(json.f_inv)) { return false }
    if (!json.b_high || !isColor(json.b_high)) { return false }
    if (!json.b_med || !isColor(json.b_med)) { return false }
    if (!json.b_low || !isColor(json.b_low)) { return false }
    if (!json.b_inv || !isColor(json.b_inv)) { return false }
    return true
  }
  function isColor (hex) {
    return /^#([0-9A-F]{3}){1,2}$/i.test(hex)
  }
  function isJson (text) {
    try { JSON.parse(text); return true } catch (error) { return false }
  }
  function isHtml (text) {
    try { new DOMParser().parseFromString(text, 'text/xml'); return true } catch (error) { return false }
  }
}
'use strict'
function Client () {
  this.install = function (host) {
    console.info('Client', 'Installing..')
    this.acels = new Acels(this)
    this.theme = new Theme(this)
    this.history = new History(this)
    this.source = new Source(this)
    this.manager = new Manager(this)
    this.renderer = new Renderer(this)
    this.tool = new Tool(this)
    this.interface = new Interface(this)
    this.picker = new Picker(this)
    this.cursor = new Cursor(this)
    host.appendChild(this.renderer.el)
    document.addEventListener('mousedown', (e) => { this.cursor.down(e) }, false)
    document.addEventListener('mousemove', (e) => { this.cursor.move(e) }, false)
    document.addEventListener('contextmenu', (e) => { this.cursor.alt(e) }, false)
    document.addEventListener('mouseup', (e) => { this.cursor.up(e) }, false)
    document.addEventListener('copy', (e) => { this.copy(e) }, false)
    document.addEventListener('cut', (e) => { this.cut(e) }, false)
    document.addEventListener('paste', (e) => { this.paste(e) }, false)
    window.addEventListener('resize', (e) => { this.onResize() }, false)
    window.addEventListener('dragover', (e) => { e.stopPropagation(); e.preventDefault(); e.dataTransfer.dropEffect = 'copy' })
    window.addEventListener('drop', this.onDrop)
    this.acels.set('∷', 'Toggle Menubar', 'Tab', () => { this.acels.toggle() })
    this.acels.set('∷', 'Open Theme', 'CmdOrCtrl+Shift+O', () => { this.theme.open() })
    this.acels.set('∷', 'Reset Theme', 'CmdOrCtrl+Backspace', () => { this.theme.reset() })
    this.acels.set('File', 'New', 'CmdOrCtrl+N', () => { this.tool.erase(); this.update(); this.source.new() })
    this.acels.set('File', 'Open', 'CmdOrCtrl+O', () => { this.source.open('grid', this.whenOpen) })
    this.acels.set('File', 'Save', 'CmdOrCtrl+S', () => { this.source.write('dotgrid', 'grid', this.tool.export(), 'text/plain') })
    this.acels.set('File', 'Export Vector', 'CmdOrCtrl+E', () => { this.source.write('dotgrid', 'svg', this.manager.toString(), 'image/svg+xml') })
    this.acels.set('File', 'Export Image', 'CmdOrCtrl+Shift+E', () => { this.manager.toPNG(this.tool.settings.size, (dataUrl) => { this.source.write('dotgrid', 'png', dataUrl, 'image/png') }) })
    this.acels.set('Edit', 'Undo', 'CmdOrCtrl+Z', () => { this.tool.undo() })
    this.acels.set('Edit', 'Redo', 'CmdOrCtrl+Shift+Z', () => { this.tool.redo() })
    this.acels.set('View', 'Color Picker', 'G', () => { this.picker.start() })
    this.acels.set('View', 'Toggle Grid', 'H', () => { this.renderer.toggle() })
    this.acels.set('View', 'Toggle Tools', 'CmdOrCtrl+H', () => { this.interface.toggle() })
    this.acels.set('Layers', 'Foreground', 'CmdOrCtrl+1', () => { this.tool.selectLayer(0) })
    this.acels.set('Layers', 'Middleground', 'CmdOrCtrl+2', () => { this.tool.selectLayer(1) })
    this.acels.set('Layers', 'Background', 'CmdOrCtrl+3', () => { this.tool.selectLayer(2) })
    this.acels.set('Layers', 'Merge Layers', 'CmdOrCtrl+M', () => { this.tool.merge() })
    this.acels.set('Stroke', 'Line', 'A', () => { this.tool.cast('line') })
    this.acels.set('Stroke', 'Arc', 'S', () => { this.tool.cast('arc_c') })
    this.acels.set('Stroke', 'Arc Rev', 'D', () => { this.tool.cast('arc_r') })
    this.acels.set('Stroke', 'Bezier', 'F', () => { this.tool.cast('bezier') })
    this.acels.set('Stroke', 'Close', 'Z', () => { this.tool.cast('close') })
    this.acels.set('Stroke', 'Arc(full)', 'T', () => { this.tool.cast('arc_c_full') })
    this.acels.set('Stroke', 'Arc Rev(full)', 'Y', () => { this.tool.cast('arc_r_full') })
    this.acels.set('Stroke', 'Clear Selection', 'Escape', () => { this.tool.clear() })
    this.acels.set('Stroke', 'Erase Segment', 'Backspace', () => { this.tool.removeSegment() })
    this.acels.set('Control', 'Add Point', 'Enter', () => { this.tool.addVertex(this.cursor.pos); this.renderer.update() })
    this.acels.set('Control', 'Move Up', 'Up', () => { this.cursor.pos.y -= 15; this.renderer.update() })
    this.acels.set('Control', 'Move Right', 'Right', () => { this.cursor.pos.x += 15; this.renderer.update() })
    this.acels.set('Control', 'Move Down', 'Down', () => { this.cursor.pos.y += 15; this.renderer.update() })
    this.acels.set('Control', 'Move Left', 'Left', () => { this.cursor.pos.x -= 15; this.renderer.update() })
    this.acels.set('Control', 'Remove Point', 'X', () => { this.tool.removeSegmentsAt(this.cursor.pos) })
    this.acels.set('Style', 'Linecap', 'Q', () => { this.tool.toggle('linecap') })
    this.acels.set('Style', 'Linejoin', 'W', () => { this.tool.toggle('linejoin') })
    this.acels.set('Style', 'Mirror', 'E', () => { this.tool.toggle('mirror') })
    this.acels.set('Style', 'Fill', 'R', () => { this.tool.toggle('fill') })
    this.acels.set('Style', 'Thicker', '}', () => { this.tool.toggle('thickness', 1) })
    this.acels.set('Style', 'Thinner', '{', () => { this.tool.toggle('thickness', -1) })
    this.acels.set('Style', 'Thicker +5', ']', () => { this.tool.toggle('thickness', 5) })
    this.acels.set('Style', 'Thinner -5', '[', () => { this.tool.toggle('thickness', -5) })
    this.acels.route(this)
    this.manager.install()
    this.interface.install(host)
    this.theme.install(host, () => { this.update() })
    this.acels.install(host)
  }
  this.start = () => {
    console.log('Client', 'Starting..')
    console.info(`${this.acels}`)
    this.theme.start()
    this.acels.start()
    this.tool.start()
    this.renderer.start()
    this.interface.start()
    this.history.push(this.layers) // initial state
    this.source.new()
    this.onResize()
    this.interface.update(true) // force an update
    setTimeout(() => { document.body.className += ' ready' }, 250)
  }
  this.update = () => {
    this.manager.update()
    this.interface.update()
    this.renderer.update()
  }
  this.clear = () => {
    this.history.clear()
    this.tool.reset()
    this.reset()
    this.renderer.update()
    this.interface.update(true)
  }
  this.reset = () => {
    this.tool.clear()
    this.update()
  }
  this.whenOpen = (file, data) => {
    this.tool.replace(JSON.parse(data))
    this.onResize()
  }
  this.fitSize = () => {
    if (this.requireResize() === false) { return }
    console.log('Client', `Will resize to: ${printSize(this.getRequiredSize())}`)
    this.update()
  }
  this.getPadding = () => {
    return { x: 60, y: 90 }
  }
  this.getWindowSize = () => {
    return { width: window.innerWidth, height: window.innerHeight }
  }
  this.getProjectSize = () => {
    return this.tool.settings.size
  }
  this.getPaddedSize = () => {
    const rect = this.getWindowSize()
    const pad = this.getPadding()
    return { width: step(rect.width - pad.x, 15), height: step(rect.height - pad.y, 15) }
  }
  this.getRequiredSize = () => {
    const rect = this.getProjectSize()
    const pad = this.getPadding()
    return { width: step(rect.width, 15) + pad.x, height: step(rect.height, 15) + pad.y }
  }
  this.requireResize = () => {
    const _window = this.getWindowSize()
    const _required = this.getRequiredSize()
    const offset = sizeOffset(_window, _required)
    if (offset.width !== 0 || offset.height !== 0) {
      console.log('Client', `Require ${printSize(_required)}, but window is ${printSize(_window)}(${printSize(offset)})`)
      return true
    }
    return false
  }
  this.onResize = () => {
    const _project = this.getProjectSize()
    const _padded = this.getPaddedSize()
    const offset = sizeOffset(_padded, _project)
    if (offset.width !== 0 || offset.height !== 0) {
      console.log('Client', `Resize project to ${printSize(_padded)}`)
      this.tool.settings.size = _padded
    }
    this.update()
  }
  this.drag = function (e) {
    e.preventDefault()
    e.stopPropagation()
    const file = e.dataTransfer.files[0]
    const filename = file.path ? file.path : file.name ? file.name : ''
    if (filename.indexOf('.grid') < 0) { console.warn('Client', 'Not a .grid file'); return }
    const reader = new FileReader()
    reader.onload = function (e) {
      const data = e.target && e.target.result ? e.target.result : ''
      this.source.load(filename, data)
      this.fitSize()
    }
    reader.readAsText(file)
  }
  this.onDrop = (e) => {
    e.preventDefault()
    e.stopPropagation()
    const file = e.dataTransfer.files[0]
    if (file.name.indexOf('.grid') > -1) {
      this.source.read(e.dataTransfer.files[0], this.whenOpen)
    }
  }
  this.copy = function (e) {
    this.renderer.update()
    if (e.target !== this.picker.input) {
      e.clipboardData.setData('text/source', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/plain', this.tool.path())
      e.clipboardData.setData('text/html', this.manager.el.outerHTML)
      e.clipboardData.setData('text/svg+xml', this.manager.el.outerHTML)
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.cut = function (e) {
    this.renderer.update()
    if (e.target !== this.picker.input) {
      e.clipboardData.setData('text/source', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/plain', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/html', this.manager.el.outerHTML)
      e.clipboardData.setData('text/svg+xml', this.manager.el.outerHTML)
      this.tool.layers[this.tool.index] = []
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.paste = function (e) {
    if (e.target !== this.picker.el) {
      let data = e.clipboardData.getData('text/source')
      if (isJson(data)) {
        data = JSON.parse(data.trim())
        this.tool.import(data)
      }
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.onKeyDown = (e) => {
  }
  this.onKeyUp = (e) => {
  }
  function sizeOffset (a, b) { return { width: a.width - b.width, height: a.height - b.height } }
  function printSize (size) { return `${size.width}x${size.height}` }
  function isJson (text) { try { JSON.parse(text); return true } catch (error) { return false } }
  function step (v, s) { return Math.round(v / s) * s }
}
'use strict'
function Cursor (client) {
  this.pos = { x: 0, y: 0 }
  this.lastPos = { x: 0, y: 0 }
  this.translation = null
  this.operation = null
  this.translate = function (from = null, to = null, multi = false, copy = false, layer = false) {
    if ((from || to) && this.translation === null) { this.translation = { multi: multi, copy: copy, layer: layer } }
    if (from) { this.translation.from = from }
    if (to) { this.translation.to = to }
    if (!from && !to) {
      this.translation = null
    }
  }
  this.down = function (e) {
    this.pos = this.atEvent(e)
    if (client.tool.vertexAt(this.pos)) {
      this.translate(this.pos, this.pos, e.shiftKey, e.ctrlKey || e.metaKey, e.altKey)
    }
    client.renderer.update()
    client.interface.update()
    e.preventDefault()
  }
  this.move = function (e) {
    this.pos = this.atEvent(e)
    if (this.translation) {
      this.translate(null, this.pos)
    }
    if (this.lastPos.x !== this.pos.x || this.lastPos.y !== this.pos.y) {
      client.renderer.update()
    }
    client.interface.update()
    this.lastPos = this.pos
    e.preventDefault()
  }
  this.up = function (e) {
    this.pos = this.atEvent(e)
    if (this.translation && !isEqual(this.translation.from, this.translation.to)) {
      if (this.translation.layer === true) { client.tool.translateLayer(this.translation.from, this.translation.to) } else if (this.translation.copy) { client.tool.translateCopy(this.translation.from, this.translation.to) } else if (this.translation.multi) { client.tool.translateMulti(this.translation.from, this.translation.to) } else { client.tool.translate(this.translation.from, this.translation.to) }
    } else if (e.target.id === 'guide') {
      client.tool.addVertex({ x: this.pos.x, y: this.pos.y })
      client.picker.stop()
    }
    this.translate()
    client.interface.update()
    client.renderer.update()
    e.preventDefault()
  }
  this.alt = function (e) {
    this.pos = this.atEvent(e)
    client.tool.removeSegmentsAt(this.pos)
    e.preventDefault()
    setTimeout(() => {
      client.tool.clear()
    }, 150)
  }
  this.atEvent = function (e) {
    return this.snapPos(this.relativePos({ x: e.clientX, y: e.clientY }))
  }
  this.relativePos = function (pos) {
    return {
      x: pos.x - client.renderer.el.offsetLeft,
      y: pos.y - client.renderer.el.offsetTop
    }
  }
  this.snapPosSquare = function (pos) {
    return {
      x: clamp(step(pos.x, 15), 15, client.tool.settings.size.width - 15),
      y: clamp(step(pos.y, 15), 15, client.tool.settings.size.height - 15)
    }
  }
  this.snapPosTriangle = function (pos) {
    const yScale = 10*Math.sqrt(3);
    const y = clamp(step(pos.y, yScale), yScale, client.tool.settings.size.height - yScale)
    const xRow = Math.round((y/yScale)) % 2
    const xRowShift = (xRow||-1)*5
    return {
      x: xRowShift + clamp(step(pos.x, 20), 20, client.tool.settings.size.width - 20),
      y: y
    }
  }
  this.snapPos = this.snapPosTriangle;
  function isEqual (a, b) { return a.x === b.x && a.y === b.y }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
  function step (v, s) { return Math.round(v / s) * s }
}
'use strict'
function Generator (layer, style) {
  this.layer = layer
  this.style = style
  function operate (layer, offset, scale, mirror = 0, angle = 0) {
    const l = copy(layer)
    for (const k1 in l) {
      const seg = l[k1]
      for (const k2 in seg.vertices) {
        if (mirror === 1 || mirror === 3) { seg.vertices[k2].x = (client.tool.settings.size.width) - seg.vertices[k2].x }
        if (mirror === 2 || mirror === 3) { seg.vertices[k2].y = (client.tool.settings.size.height) - seg.vertices[k2].y }
        seg.vertices[k2].x += offset.x
        seg.vertices[k2].y += offset.y
        const center = { x: (client.tool.settings.size.width / 2) + offset.x + (7.5), y: (client.tool.settings.size.height / 2) + offset.y + 30 }
        seg.vertices[k2] = rotatePoint(seg.vertices[k2], center, angle)
        seg.vertices[k2].x *= scale
        seg.vertices[k2].y *= scale
      }
    }
    return l
  }
  this.render = function (prev, segment, mirror = 0) {
    const type = segment.type
    const vertices = segment.vertices
    let html = ''
    let skip = 0
    for (const id in vertices) {
      if (skip > 0) { skip -= 1; continue }
      const vertex = vertices[parseInt(id)]
      const next = vertices[parseInt(id) + 1]
      const afterNext = vertices[parseInt(id) + 2]
      if (parseInt(id) === 0 && !prev) {
        html += `M${vertex.x},${vertex.y} `
      } else if (parseInt(id) === 0 && prev && (prev.x !== vertex.x || prev.y !== vertex.y)) {
        html += `M${vertex.x},${vertex.y} `
      }
      if (type === 'line') {
        html += this._line(vertex)
      } else if (type === 'arc_c') {
        const clock = mirror > 0 && mirror < 3 ? '0,0' : '0,1'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_r') {
        const clock = mirror > 0 && mirror < 3 ? '0,1' : '0,0'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_c_full') {
        const clock = mirror > 0 ? '1,0' : '1,1'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_r_full') {
        const clock = mirror > 0 ? '1,1' : '1,0'
        html += this._arc(vertex, next, clock)
      } else if (type === 'bezier') {
        html += this._bezier(next, afterNext)
        skip = 1
      }
    }
    if (segment.type === 'close') {
      html += 'Z '
    }
    return html
  }
  this._line = function (a) {
    return `L${a.x},${a.y} `
  }
  this._arc = function (a, b, c) {
    if (!a || !b || !c) { return '' }
    const offset = { x: b.x - a.x, y: b.y - a.y }
    if (offset.x === 0 || offset.y === 0) { return this._line(b) }
    return `A${Math.abs(b.x - a.x)},${Math.abs(b.y - a.y)} 0 ${c} ${b.x},${b.y} `
  }
  this._bezier = function (a, b) {
    if (!a || !b) { return '' }
    return `Q${a.x},${a.y} ${b.x},${b.y} `
  }
  this.convert = function (layer, mirror, angle) {
    let s = ''
    let prev = null
    for (const id in layer) {
      const seg = layer[parseInt(id)]
      s += `${this.render(prev, seg, mirror)}`
      prev = seg.vertices ? seg.vertices[seg.vertices.length - 1] : null
    }
    return s
  }
  this.toString = function (offset = { x: 0, y: 0 }, scale = 1, mirror = this.style && this.style.mirror_style ? this.style.mirror_style : 0) {
    let s = this.convert(operate(this.layer, offset, scale))
    if (mirror === 1 || mirror === 2 || mirror === 3) {
      s += this.convert(operate(this.layer, offset, scale, mirror), mirror)
    }
    return s
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function rotatePoint (point, origin, angle) { angle = angle * Math.PI / 180.0; return { x: (Math.cos(angle) * (point.x - origin.x) - Math.sin(angle) * (point.y - origin.y) + origin.x).toFixed(1), y: (Math.sin(angle) * (point.x - origin.x) + Math.cos(angle) * (point.y - origin.y) + origin.y).toFixed(1) } }
}
'use strict'
function Interface (client) {
  this.el = document.createElement('div')
  this.el.id = 'interface'
  this.el.appendChild(this.menu_el = document.createElement('div'))
  this.menu_el.id = 'menu'
  this.isVisible = true
  this.zoom = false
  const options = {
    cast: {
      line: { key: 'A', icon: 'M60,60 L240,240' },
      arc_c: { key: 'S', icon: 'M60,60 A180,180 0 0,1 240,240' },
      arc_r: { key: 'D', icon: 'M60,60 A180,180 0 0,0 240,240' },
      bezier: { key: 'F', icon: 'M60,60 Q60,150 150,150 Q240,150 240,240' },
      close: { key: 'Z', icon: 'M60,60 A180,180 0 0,1 240,240  M60,60 A180,180 0 0,0 240,240' }
    },
    toggle: {
      linecap: { key: 'Q', icon: 'M60,60 L60,60 L180,180 L240,180 L240,240 L180,240 L180,180' },
      linejoin: { key: 'W', icon: 'M60,60 L120,120 L180,120  M120,180 L180,180 L240,240' },
      thickness: { key: '', icon: 'M120,90 L120,90 L90,120 L180,210 L210,180 Z M105,105 L105,105 L60,60 M195,195 L195,195 L240,240' },
      mirror: { key: 'E', icon: 'M60,60 L60,60 L120,120 M180,180 L180,180 L240,240 M210,90 L210,90 L180,120 M120,180 L120,180 L90,210' },
      fill: { key: 'R', icon: 'M60,60 L60,150 L150,150 L240,150 L240,240 Z' }
    },
    misc: {
      color: { key: 'G', icon: 'M150,60 A90,90 0 0,1 240,150 A-90,90 0 0,1 150,240 A-90,-90 0 0,1 60,150 A90,-90 0 0,1 150,60' }
    },
    source: {
      open: { key: 'c-O', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M155,95 A60,60 0 0,1 215,155 A60,60 0 0,1 155,215 A60,60 0 0,1 95,155 A60,60 0 0,1 155,95 ' },
      render: { key: 'c-R', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,155 L110,155 L200,155 ' },
      export: { key: 'c-E', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,140 L110,140 L200,140 M110,170 L110,170 L200,170' },
      save: { key: 'c-S', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,155 L110,155 L200,155 M110,185 L110,185 L200,185 M110,125 L110,125 L200,125' },
      grid: { key: 'H', icon: 'M65,155 Q155,245 245,155 M65,155 Q155,65 245,155 M155,125 A30,30 0 0,1 185,155 A30,30 0 0,1 155,185 A30,30 0 0,1 125,155 A30,30 0 0,1 155,125 ' }
    }
  }
  const mirrorPaths = [
    'M60,60 L60,60 L120,120 M180,180 L180,180 L240,240 M210,90 L210,90 L180,120 M120,180 L120,180 L90,210',
    'M60,60 L240,240 M180,120 L210,90 M120,180 L90,210',
    'M210,90 L210,90 L90,210 M60,60 L60,60 L120,120 M180,180 L180,180 L240,240',
    'M60,60 L60,60 L120,120 L180,120 L210,90 M240,240 L240,240 L180,180 L120,180 L90,210',
    'M120,120 L120,120 L120,120 L180,120 M120,150 L120,150 L180,150 M120,180 L120,180 L180,180 L180,180 L180,180 L240,240 M120,210 L120,210 L180,210 M120,90 L120,90 L180,90 M60,60 L60,60 L120,120  '
  ]
  this.install = function (host) {
    host.appendChild(this.el)
  }
  this.start = function (host) {
    let html = ''
    for (const type in options) {
      const tools = options[type]
      for (const name in tools) {
        const tool = tools[name]
        html += `
        <svg 
          id="option_${name}" 
          title="${capitalize(name)}" 
          onmouseout="client.interface.out('${type}','${name}')" 
          onmouseup="client.interface.up('${type}','${name}')" 
          onmousedown="client.interface.down('${type}','${name}', event)" 
          onmouseover="client.interface.over('${type}','${name}')" 
          viewBox="0 0 300 300" 
          class="icon ${type}">
          <path id="${name}_path" class="icon_path" d="${tool.icon}"/>${name === 'depth' ? '<path class="icon_path inactive" d=""/>' : ''}
          <rect ar="${name}" width="300" height="300" opacity="0">
            <title>${capitalize(name)}${tool.key ? '(' + tool.key + ')' : ''}</title>
          </rect>
        </svg>`
      }
    }
    this.menu_el.innerHTML = html
    for (const type in options) {
      const tools = options[type]
      for (const name in tools) {
        const tool = tools[name]
        tool.el = document.getElementById('option_' + name)
      }
    }
    this.menu_el.appendChild(client.picker.el)
  }
  this.over = function (type, name) {
    client.cursor.operation = {}
    client.cursor.operation[type] = name
    this.update(true)
    client.renderer.update(true)
  }
  this.out = function (type, name) {
    client.cursor.operation = ''
    client.renderer.update(true)
  }
  this.up = function (type, name) {
    if (!client.tool[type]) { console.warn(`Unknown option(type): ${type}.${name}`, client.tool); return }
    this.update(true)
    client.renderer.update(true)
  }
  this.down = function (type, name, event) {
    if (!client.tool[type]) { console.warn(`Unknown option(type): ${type}.${name}`, client.tool); return }
    const mod = event.button === 2 ? -1 : 1
    client.tool[type](name, mod)
    this.update(true)
    client.renderer.update(true)
  }
  this.prev_operation = null
  this.update = function (force = false, id) {
    if (this.prev_operation === client.cursor.operation && force === false) { return }
    let multiVertices = null
    const segments = client.tool.layer()
    const sumSegments = client.tool.length()
    for (const i in segments) {
      if (segments[i].vertices.length > 2) { multiVertices = true; break }
    }
    options.cast.line.el.className.baseVal = !client.tool.canCast('line') ? 'icon inactive' : 'icon'
    options.cast.arc_c.el.className.baseVal = !client.tool.canCast('arc_c') ? 'icon inactive' : 'icon'
    options.cast.arc_r.el.className.baseVal = !client.tool.canCast('arc_r') ? 'icon inactive' : 'icon'
    options.cast.bezier.el.className.baseVal = !client.tool.canCast('bezier') ? 'icon inactive' : 'icon'
    options.cast.close.el.className.baseVal = !client.tool.canCast('close') ? 'icon inactive' : 'icon'
    options.toggle.thickness.el.className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    options.toggle.linecap.el.className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    options.toggle.linejoin.el.className.baseVal = client.tool.layer().length < 1 || !multiVertices ? 'icon inactive' : 'icon'
    options.toggle.mirror.el.className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    options.toggle.fill.el.className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    options.misc.color.el.children[0].style.fill = client.tool.style().color
    options.misc.color.el.children[0].style.stroke = client.tool.style().color
    options.misc.color.el.className.baseVal = 'icon'
    options.source.save.el.className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    options.source.export.el.className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    options.source.render.el.className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    options.source.grid.el.className.baseVal = client.renderer.showExtras ? 'icon inactive source' : 'icon source'
    document.getElementById('grid_path').setAttribute('d', client.renderer.showExtras ? 'M65,155 Q155,245 245,155 M65,155 Q155,65 245,155 M155,125 A30,30 0 0,1 185,155 A30,30 0 0,1 155,185 A30,30 0 0,1 125,155 A30,30 0 0,1 155,125 ' : 'M65,155 Q155,245 245,155 M65,155 ')
    document.getElementById('mirror_path').setAttribute('d', mirrorPaths[client.tool.style().mirror_style])
    this.prev_operation = client.cursor.operation
  }
  this.toggle = function () {
    this.isVisible = !this.isVisible
    this.el.className = this.isVisible ? 'visible' : 'hidden'
  }
  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
  }
}
'use strict'
function Manager (client) {
  this.el = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  this.el.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
  this.el.setAttribute('baseProfile', 'full')
  this.el.setAttribute('version', '1.1')
  this.el.style.fill = 'none'
  this.layers = []
  this.install = function () {
    this.el.appendChild(this.layers[2] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
    this.el.appendChild(this.layers[1] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
    this.el.appendChild(this.layers[0] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
  }
  this.update = function () {
    this.el.setAttribute('width', (client.tool.settings.size.width) + 'px')
    this.el.setAttribute('height', (client.tool.settings.size.height) + 'px')
    this.el.style.width = (client.tool.settings.size.width)
    this.el.style.height = client.tool.settings.size.height
    const styles = client.tool.styles
    const paths = client.tool.paths()
    for (const id in this.layers) {
      const style = styles[id]
      const path = paths[id]
      const layer = this.layers[id]
      layer.style.strokeWidth = style.thickness
      layer.style.strokeLinecap = style.strokeLinecap
      layer.style.strokeLinejoin = style.strokeLinejoin
      layer.style.stroke = style.color
      layer.style.fill = style.fill
      layer.setAttribute('d', path)
    }
  }
  this.svg64 = function () {
    const xml = new XMLSerializer().serializeToString(this.el)
    const svg64 = btoa(xml)
    const b64Start = 'data:image/svg+xml;base64,'
    return b64Start + svg64
  }
  this.toPNG = function (size = client.tool.settings.size, callback) {
    this.update()
    const image64 = this.svg64()
    const img = new Image()
    const canvas = document.createElement('canvas')
    canvas.width = (size.width) * 2
    canvas.height = (size.height) * 2
    img.onload = function () {
      canvas.getContext('2d').drawImage(img, 0, 0, (size.width) * 2, (size.height) * 2)
      callback(canvas.toDataURL('image/png'))
    }
    img.src = image64
  }
  this.toSVG = function (callback) {
    this.update()
    const image64 = this.svg64()
    callback(image64, 'export.svg')
  }
  this.toGRID = function (callback) {
    this.update()
    const text = client.tool.export()
    const file = new Blob([text], { type: 'text/plain' })
    callback(URL.createObjectURL(file), 'export.grid')
  }
  this.toString = () => {
    return new XMLSerializer().serializeToString(this.el)
  }
}
'use strict'
function Picker (client) {
  this.memory = ''
  this.el = document.createElement('div')
  this.el.id = 'picker'
  this.isActive = false
  this.input = document.createElement('input')
  this.input.id = 'picker_input'
  this.el.appendChild(this.input)
  this.start = function () {
    if (this.isActive) { return }
    this.isActive = true
    this.input.setAttribute('placeholder', `${client.tool.style().color.replace('#', '').trim()}`)
    this.input.setAttribute('maxlength', 6)
    this.input.addEventListener('keydown', this.onKeyDown, false)
    this.input.addEventListener('keyup', this.onKeyUp, false)
    client.interface.el.className = 'picker'
    this.input.focus()
    this.input.value = ''
    try { client.controller.set('picker') } catch (err) { }
  }
  this.update = function () {
    if (!this.isActive) { return }
    if (!isColor(this.input.value)) { return }
    const hex = `#${this.input.value}`
    document.getElementById('option_color').children[0].style.fill = hex
    document.getElementById('option_color').children[0].style.stroke = hex
  }
  this.stop = function () {
    if (!this.isActive) { return }
    this.isActive = false
    client.interface.el.className = ''
    this.input.blur()
    this.input.value = ''
    try { client.controller.set() } catch (err) { console.log('No controller') }
    setTimeout(() => { client.interface.update(true); client.renderer.update() }, 250)
  }
  this.validate = function () {
    if (!isColor(this.input.value)) { return }
    const hex = `#${this.input.value}`
    client.tool.style().color = hex
    client.tool.style().fill = client.tool.style().fill !== 'none' ? hex : 'none'
    this.stop()
  }
  function isColor (val) {
    if (val.length !== 3 && val.length !== 6) {
      return false
    }
    const re = /[0-9A-Fa-f]/g
    return re.test(val)
  }
  this.onKeyDown = (e) => {
    e.stopPropagation()
    if (e.key === 'Enter') {
      this.validate()
      e.preventDefault()
      return
    }
    if (e.key === 'Escape') {
      this.stop()
      e.preventDefault()
    }
  }
  this.onKeyUp = (e) => {
    e.stopPropagation()
    this.update()
  }
}
'use strict'
function Renderer (client) {
  this.el = document.createElement('canvas')
  this.el.id = 'guide'
  this.el.width = 640
  this.el.height = 640
  this.el.style.width = '320px'
  this.el.style.height = '320px'
  this.context = this.el.getContext('2d')
  this.showExtras = true
  this.scale = 2 // window.devicePixelRatio
  this.start = function () {
    this.update()
  }
  this.update = function (force = false) {
    this.resize()
    client.manager.update()
    const render = new Image()
    render.onload = () => {
      this.draw(render)
    }
    render.src = client.manager.svg64()
  }
  this.draw = function (render) {
    this.clear()
    this.drawMirror()
    this.drawGrid()
    this.drawRulers()
    this.drawRender(render) //
    this.drawVertices()
    this.drawHandles()
    this.drawTranslation()
    this.drawCursor()
    this.drawPreview()
  }
  this.clear = function () {
    this.context.clearRect(0, 0, this.el.width * this.scale, this.el.height * this.scale)
  }
  this.toggle = function () {
    this.showExtras = !this.showExtras
    this.update()
    client.interface.update(true)
  }
  this.resize = function () {
    const _target = client.getPaddedSize()
    const _current = { width: this.el.width / this.scale, height: this.el.height / this.scale }
    const offset = sizeOffset(_target, _current)
    if (offset.width === 0 && offset.height === 0) {
      return
    }
    console.log('Renderer', `Require resize: ${printSize(_target)}, from ${printSize(_current)}`)
    this.el.width = (_target.width) * this.scale
    this.el.height = (_target.height) * this.scale
    this.el.style.width = (_target.width) + 'px'
    this.el.style.height = (_target.height) + 'px'
  }
  this.drawMirror = function () {
    if (!this.showExtras) { return }
    if (client.tool.style().mirror_style === 0) { return }
    const middle = { x: client.tool.settings.size.width, y: client.tool.settings.size.height }
    if (client.tool.style().mirror_style === 1 || client.tool.style().mirror_style === 3) {
      this.drawRule({ x: middle.x, y: 15 * this.scale }, { x: middle.x, y: (client.tool.settings.size.height) * this.scale })
    }
    if (client.tool.style().mirror_style === 2 || client.tool.style().mirror_style === 3) {
      this.drawRule({ x: 15 * this.scale, y: middle.y }, { x: (client.tool.settings.size.width) * this.scale, y: middle.y })
    }
  }
  this.drawHandles = function () {
    if (!this.showExtras) { return }
    for (const segmentId in client.tool.layer()) {
      const segment = client.tool.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        this.drawHandle(vertex)
      }
    }
  }
  this.drawVertices = function () {
    for (const id in client.tool.vertices) {
      this.drawVertex(client.tool.vertices[id])
    }
  }
  this.drawGridPointsSquare = function (width, height) {
    const markers = { w: parseInt(width / 15), h: parseInt(height / 15) }
    for (let x = markers.w - 1; x >= 0; x--) {
      for (let y = markers.h - 1; y >= 0; y--) {
        const isStep = x % 4 === 0 && y % 4 === 0
        if (x === 0 || y === 0) { continue }
        const pos = {
          x: parseInt(x * 15),
          y: parseInt(y * 15)
        }
        const radius = isStep ? 2.5 : 1.5
        this.context.moveTo(pos.x * this.scale, pos.y * this.scale)
        this.context.arc(pos.x * this.scale, pos.y * this.scale, radius, 0, 2 * Math.PI, false)
      }
    }
  }
  this.drawGridPointsTriangle = function (width, height) {
    const yScale = 10*Math.sqrt(3);
    const markers = { w: parseInt(width / 20), h: parseInt(height / yScale) }
    for (let x = markers.w - 1; x >= 0; x--) {
      for (let y = markers.h - 1; y >= 0; y--) {
        const isStep = x % 4 === 0 && y % 8 === 0 || x % 4 === 2 && y % 8 === 4
        if (x === 0 || y === 0) { continue }
        const pos = {
          x: (y%2|| -1) * 5 + parseInt(x * 20),
          y: parseInt(y * yScale)
        }
        const radius = isStep ? 2.5 : 1.5
        this.context.moveTo(pos.x * this.scale, pos.y * this.scale)
        this.context.arc(pos.x * this.scale, pos.y * this.scale, radius, 0, 2 * Math.PI, false)
      }
    }
  }
  this.drawGridPoints = this.drawGridPointsTriangle
  this.drawGrid = function () {
    if (!this.showExtras) { return }
    this.context.beginPath()
    this.context.lineWidth = 2
    this.context.fillStyle = client.theme.active.b_med
    this.drawGridPoints(client.tool.settings.size.width, client.tool.settings.size.height)
    this.context.fill()
    this.context.closePath()
  }
  this.drawRulers = function () {
    if (!client.cursor.translation) { return }
    const pos = client.cursor.translation.to
    const bottom = (client.tool.settings.size.height * this.scale)
    const right = (client.tool.settings.size.width * this.scale)
    this.drawRule({ x: pos.x * this.scale, y: 0 }, { x: pos.x * this.scale, y: bottom })
    this.drawRule({ x: 0, y: pos.y * this.scale }, { x: right, y: pos.y * this.scale })
  }
  this.drawPreview = function () {
    const operation = client.cursor.operation && client.cursor.operation.cast ? client.cursor.operation.cast : null
    if (!client.tool.canCast(operation)) { return }
    if (operation === 'close') { return }
    const path = new Generator([{ vertices: client.tool.vertices, type: operation }]).toString({ x: 0, y: 0 }, 2)
    const style = {
      color: client.theme.active.f_med,
      thickness: 2,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeLineDash: [5, 15]
    }
    this.drawPath(path, style)
  }
  this.drawVertex = function (pos, radius = 5) {
    this.context.beginPath()
    this.context.lineWidth = 2
    this.context.arc((pos.x * this.scale), (pos.y * this.scale), radius, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.f_low
    this.context.fill()
    this.context.closePath()
  }
  this.drawRule = function (from, to) {
    this.context.beginPath()
    this.context.moveTo(from.x, from.y)
    this.context.lineTo(to.x, to.y)
    this.context.lineCap = 'round'
    this.context.lineWidth = 3
    this.context.strokeStyle = client.theme.active.b_low
    this.context.stroke()
    this.context.closePath()
  }
  this.drawHandle = function (pos, radius = 6) {
    this.context.beginPath()
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), radius + 3, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.f_high
    this.context.fill()
    this.context.closePath()
    this.context.beginPath()
    this.context.arc((pos.x * this.scale), (pos.y * this.scale), radius - 3, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.b_low
    this.context.fill()
    this.context.closePath()
  }
  this.drawPath = function (path, style) {
    const p = new Path2D(path)
    this.context.strokeStyle = style.color
    this.context.lineWidth = style.thickness * this.scale
    this.context.lineCap = style.strokeLinecap
    this.context.lineJoin = style.strokeLinejoin
    if (style.fill && style.fill !== 'none') {
      this.context.fillStyle = style.color
      this.context.fill(p)
    }
    this.context.save()
    if (style.strokeLineDash) { this.context.setLineDash(style.strokeLineDash) } else { this.context.setLineDash([]) }
    this.context.stroke(p)
    this.context.restore()
  }
  this.drawTranslation = function () {
    if (!client.cursor.translation) { return }
    this.context.save()
    this.context.beginPath()
    this.context.moveTo((client.cursor.translation.from.x * this.scale), (client.cursor.translation.from.y * this.scale))
    this.context.lineTo((client.cursor.translation.to.x * this.scale), (client.cursor.translation.to.y * this.scale))
    this.context.lineCap = 'round'
    this.context.lineWidth = 5
    this.context.strokeStyle = client.cursor.translation.multi === true ? client.theme.active.b_inv : client.cursor.translation.copy === true ? client.theme.active.f_med : client.theme.active.f_low
    this.context.setLineDash([5, 10])
    this.context.stroke()
    this.context.closePath()
    this.context.setLineDash([])
    this.context.restore()
  }
  this.drawCursor = function (pos = client.cursor.pos, radius = client.tool.style().thickness - 1) {
    this.context.save()
    this.context.beginPath()
    this.context.lineWidth = 3
    this.context.lineCap = 'round'
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), 5, 0, 2 * Math.PI, false)
    this.context.strokeStyle = client.theme.active.background
    this.context.stroke()
    this.context.closePath()
    this.context.beginPath()
    this.context.lineWidth = 3
    this.context.lineCap = 'round'
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), clamp(radius, 5, 100), 0, 2 * Math.PI, false)
    this.context.strokeStyle = client.theme.active.f_med
    this.context.stroke()
    this.context.closePath()
    this.context.restore()
  }
  this.drawRender = function (render) {
    this.context.drawImage(render, 0, 0, this.el.width, this.el.height)
  }
  function printSize (size) { return `${size.width}x${size.height}` }
  function sizeOffset (a, b) { return { width: a.width - b.width, height: a.height - b.height } }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
'use strict'
function Tool (client) {
  this.index = 0
  this.settings = { size: { width: 600, height: 300 } }
  this.layers = [[], [], []]
  this.styles = [
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#f00', fill: 'none', mirror_style: 0, transform: 'rotate(45)' },
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#0f0', fill: 'none', mirror_style: 0, transform: 'rotate(45)' },
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#00f', fill: 'none', mirror_style: 0, transform: 'rotate(45)' }
  ]
  this.vertices = []
  this.reqs = { line: 2, arc_c: 2, arc_r: 2, arc_c_full: 2, arc_r_full: 2, bezier: 3, close: 0 }
  this.start = function () {
    this.styles[0].color = client.theme.active.f_high
    this.styles[1].color = client.theme.active.f_med
    this.styles[2].color = client.theme.active.f_low
  }
  this.reset = function () {
    this.styles[0].mirror_style = 0
    this.styles[1].mirror_style = 0
    this.styles[2].mirror_style = 0
    this.styles[0].fill = 'none'
    this.styles[1].fill = 'none'
    this.styles[2].fill = 'none'
    this.erase()
    this.vertices = []
    this.index = 0
  }
  this.erase = function () {
    this.layers = [[], [], []]
    this.vertices = []
    client.renderer.update()
    client.interface.update(true)
  }
  this.clear = function () {
    this.vertices = []
    client.renderer.update()
    client.interface.update(true)
  }
  this.undo = function () {
    this.layers = client.history.prev()
    client.renderer.update()
    client.interface.update(true)
  }
  this.redo = function () {
    this.layers = client.history.next()
    client.renderer.update()
    client.interface.update(true)
  }
  this.length = function () {
    return this.layers[0].length + this.layers[1].length + this.layers[2].length
  }
  this.export = function (target = { settings: this.settings, layers: this.layers, styles: this.styles }) {
    return JSON.stringify(copy(target), null, 2)
  }
  this.import = function (layer) {
    this.layers[this.index] = this.layers[this.index].concat(layer)
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.replace = function (dot) {
    if (!dot.layers || dot.layers.length !== 3) { console.warn('Incompatible version'); return }
    if (dot.settings.width && dot.settings.height) {
      dot.settings.size = { width: dot.settings.width, height: dot.settings.height }
    }
    this.layers = dot.layers
    this.styles = dot.styles
    this.settings = dot.settings
    this.clear()
    client.fitSize()
    client.renderer.update()
    client.interface.update(true)
    client.history.push(this.layers)
  }
  this.removeSegment = function () {
    if (this.vertices.length > 0) { this.clear(); return }
    this.layer().pop()
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.removeSegmentsAt = function (pos) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (Math.abs(pos.x) === Math.abs(vertex.x) && Math.abs(pos.y) === Math.abs(vertex.y)) {
          segment.vertices.splice(vertexId, 1)
        }
      }
      if (segment.vertices.length < 2) {
        this.layers[this.index].splice(segmentId, 1)
      }
    }
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.selectSegmentAt = function (pos, source = this.layer()) {
    for (const segmentId in source) {
      const segment = source[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(pos.x) && vertex.y === Math.abs(pos.y)) {
          return segment
        }
      }
    }
    return null
  }
  this.addVertex = function (pos) {
    pos = { x: Math.abs(pos.x), y: Math.abs(pos.y) }
    this.vertices.push(pos)
    client.interface.update(true)
  }
  this.vertexAt = function (pos) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(pos.x) && vertex.y === Math.abs(pos.y)) {
          return vertex
        }
      }
    }
    return null
  }
  this.addSegment = function (type, vertices, index = this.index) {
    const appendTarget = this.canAppend({ type: type, vertices: vertices }, index)
    if (appendTarget) {
      this.layer(index)[appendTarget].vertices = this.layer(index)[appendTarget].vertices.concat(vertices)
    } else {
      this.layer(index).push({ type: type, vertices: vertices })
    }
  }
  this.cast = function (type) {
    if (!this.layer()) { this.layers[this.index] = [] }
    if (!this.canCast(type)) { console.warn('Cannot cast'); return }
    this.addSegment(type, this.vertices.slice())
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
    console.log(`Casted ${type} -> ${this.layer().length} elements`)
  }
  this.i = { linecap: 0, linejoin: 0, thickness: 5 }
  this.toggle = function (type, mod = 1) {
    if (type === 'linecap') {
      const a = ['butt', 'square', 'round']
      this.i.linecap += mod
      this.style().strokeLinecap = a[this.i.linecap % a.length]
    } else if (type === 'linejoin') {
      const a = ['miter', 'round', 'bevel']
      this.i.linejoin += mod
      this.style().strokeLinejoin = a[this.i.linejoin % a.length]
    } else if (type === 'fill') {
      this.style().fill = this.style().fill === 'none' ? this.style().color : 'none'
    } else if (type === 'thickness') {
      this.style().thickness = clamp(this.style().thickness + mod, 1, 100)
    } else if (type === 'mirror') {
      this.style().mirror_style = this.style().mirror_style > 2 ? 0 : this.style().mirror_style + 1
    } else {
      console.warn('Unknown', type)
    }
    client.interface.update(true)
    client.renderer.update()
  }
  this.misc = function (type) {
    client.picker.start()
  }
  this.source = function (type) {
    if (type === 'grid') { client.renderer.toggle() }
    if (type === 'open') { client.source.open('grid', client.whenOpen) }
    if (type === 'save') { client.source.write('dotgrid', 'grid', client.tool.export(), 'text/plain') }
    if (type === 'export') { client.source.write('dotgrid', 'svg', client.manager.toString(), 'image/svg+xml') }
    if (type === 'render') { client.manager.toPNG(client.tool.settings.size, (dataUrl) => { client.source.write('dotgrid', 'png', dataUrl, 'image/png') }) }
  }
  this.canAppend = function (content, index = this.index) {
    for (const id in this.layer(index)) {
      const stroke = this.layer(index)[id]
      if (stroke.type !== content.type) { continue }
      if (!stroke.vertices) { continue }
      if (!stroke.vertices[stroke.vertices.length - 1]) { continue }
      if (stroke.vertices[stroke.vertices.length - 1].x !== content.vertices[0].x) { continue }
      if (stroke.vertices[stroke.vertices.length - 1].y !== content.vertices[0].y) { continue }
      return id
    }
    return false
  }
  this.canCast = function (type) {
    if (!type) { return false }
    if (type === 'close') {
      const prev = this.layer()[this.layer().length - 1]
      if (!prev || prev.type === 'close' || this.vertices.length !== 0) {
        return false
      }
    }
    if (type === 'bezier') {
      if (this.vertices.length !== 3 && this.vertices.length !== 5 && this.vertices.length !== 7 && this.vertices.length !== 9) {
        return false
      }
    }
    return this.vertices.length >= this.reqs[type]
  }
  this.paths = function () {
    const l1 = new Generator(client.tool.layers[0], client.tool.styles[0]).toString({ x: 0, y: 0 }, 1)
    const l2 = new Generator(client.tool.layers[1], client.tool.styles[1]).toString({ x: 0, y: 0 }, 1)
    const l3 = new Generator(client.tool.layers[2], client.tool.styles[2]).toString({ x: 0, y: 0 }, 1)
    return [l1, l2, l3]
  }
  this.path = function () {
    return new Generator(client.tool.layer(), client.tool.style()).toString({ x: 0, y: 0 }, 1)
  }
  this.translate = function (a, b) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(a.x) && vertex.y === Math.abs(a.y)) {
          segment.vertices[vertexId] = { x: Math.abs(b.x), y: Math.abs(b.y) }
        }
      }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateMulti = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    const segment = this.selectSegmentAt(a)
    if (!segment) { return }
    for (const vertexId in segment.vertices) {
      const vertex = segment.vertices[vertexId]
      segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateLayer = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
      }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateCopy = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    const segment = this.selectSegmentAt(a, copy(this.layer()))
    if (!segment) { return }
    for (const vertexId in segment.vertices) {
      const vertex = segment.vertices[vertexId]
      segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
    }
    this.layer().push(segment)
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.merge = function () {
    const merged = [].concat(this.layers[0]).concat(this.layers[1]).concat(this.layers[2])
    this.erase()
    this.layers[this.index] = merged
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.style = function () {
    if (!this.styles[this.index]) {
      this.styles[this.index] = []
    }
    return this.styles[this.index]
  }
  this.layer = function (index = this.index) {
    if (!this.layers[index]) {
      this.layers[index] = []
    }
    return this.layers[index]
  }
  this.selectLayer = function (id) {
    this.index = clamp(id, 0, 2)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
    console.log(`layer:${this.index}`)
  }
  this.selectNextLayer = function () {
    this.index = this.index >= 2 ? 0 : this.index++
    this.selectLayer(this.index)
  }
  this.selectPrevLayer = function () {
    this.index = this.index >= 0 ? 2 : this.index--
    this.selectLayer(this.index)
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
      const client = new Client()
      client.install(document.body)
      window.addEventListener('load', () => { 
        client.start()
      })
    </script>
    <style>
* { margin:0;padding:0;border:0;outline:0;text-decoration:none;font-weight:inherit;font-style:inherit;color:inherit;font-size:100%;font-family:inherit;vertical-align:baseline;list-style:none;border-collapse:collapse;border-spacing:0; -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;}
@font-face {
  font-family: 'input_mono_regular';
  src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
body { padding: 0px; font-family:"input_mono_regular",courier,monospace; -webkit-user-select: none; overflow: hidden; transition: background-color 500ms; -webkit-app-region: drag; padding: 30px;width:calc(100vw - 60px);height:calc(100vh - 60px)}
*:focus {outline: none; }
#guide { position: absolute;width: 300px;height: 300px; transition: opacity 150ms; -webkit-app-region: no-drag; border-radius: 3px;}
#render { display: none }
#vector { z-index: 1000;position: relative;width:300px; height:300px; }
#interface { font-size: 11px;line-height: 30px;text-transform: uppercase;-webkit-app-region: no-drag; transition: all 150ms; width: 100%; position:fixed; bottom:30px; left:40px; height:30px; max-width:calc(100vw - 75px); overflow: hidden;}
#interface.hidden { bottom:10px !important;opacity: 0 !important }
#interface.visible { bottom:28px !important; opacity: 1 !important}
#interface #menu { opacity: 1; position: absolute; top:0px; transition: all 250ms; z-index: 900; overflow: hidden; height:30px; width:100%;}
#interface #menu svg.icon { width:30px; height:30px; margin-right:-9px; opacity: 0.6; transition: opacity 250ms; }
#interface #menu svg.icon.inactive { opacity: 0.2 }
#interface #menu svg.icon:hover { cursor: pointer; opacity: 1.0 }
#interface #menu svg.icon:last-child { margin-right: 0; }
#interface #menu svg.icon path { fill:none; stroke-linecap: round; stroke-linejoin: round; stroke-width:12px; }
#interface #menu svg.icon.source { float:right; margin-left:-2px; margin-right:0px; }
#interface #menu svg.icon#option_color { opacity: 1.0; z-index:1001; position: relative; }
#interface #menu svg.icon#option_color:hover { opacity: 0.8 }
#interface #picker { position: absolute; line-height: 20px; z-index: 0; width: 30px; opacity: 0; transition: all 250ms; font-size: 11px; border-radius: 3px; left: 200px; top: 0px; text-transform: uppercase; height:20px; padding:5px 0px;left:280px; overflow:hidden;}
#interface #picker:before { content:"#"; position: absolute; left:10px; opacity: 0; transition: opacity 500ms}
#interface #picker input { background:transparent; position: absolute; left: 20px; height: 20px; width: 60px; line-height: 20px; opacity: 0; transition: opacity 500ms; text-transform: uppercase;}
#interface #color_path { transition: all 500ms; }
#interface.picker #menu { z-index: 0 }
#interface.picker #picker { width:30px; padding: 5px 15px; padding-right: 45px;  opacity: 1; z-index: 900; width: 50px; left:200px; opacity: 1}
#interface.picker #picker:before { opacity: 1; }
#interface.picker #picker input { opacity: 1 }
#interface.picker #option_thickness { opacity: 0 !important }
#interface.picker #option_mirror { opacity: 0 !important }
#interface.picker #option_fill { opacity: 0 !important }
body.web #interface #menu #option_open { display: none; }
body #guide { opacity: 0; transition: opacity 500ms; }
body.ready #guide { opacity: 1 }
body #interface { opacity: 0; transition: opacity 250ms, bottom 500ms; bottom:15px; }
body.ready #interface { opacity: 1; bottom:30px; }
@media (max-width: 560px) {
  #interface #menu svg.icon.source { opacity: 0; } 
}
#acels { position: fixed;width: 30px;background: red;top: 0;left: 0; width: 100vw; color:black; background:white; font-size:11px; line-height: 20px; transition: margin-top 0.25s; z-index: 9999; padding-left: 25px; }
#acels.hidden { margin-top:-20px; }
#acels.hidden > li > ul > li { display: none }
#acels > li { float: left; position: relative; cursor: pointer; padding:0px 5px; display: inline-block; }
#acels > li:hover { background: black; color:white; }
#acels > li > ul { display: none; position: absolute; background:white; position: absolute; top:20px; left:0px; color:black; width: 200px}
#acels > li:hover > ul { display: block; }
#acels > li > ul > li { padding: 0px 10px; display: block }
#acels > li > ul > li:hover { background: #ccc; }
#acels > li > ul > li > i { display: inline-block; float: right; color: #aaa; }
body { background:var(--background) !important; }
#picker { background-color:var(--b_inv) !important; color:var(--f_inv) !important; }
#picker:before { color:var(--f_med) !important; }
#picker input::placeholder { color:var(--f_med) !important; }
.fh { color:var(--f_high) !important; stroke:var(--f_high) !important; }
.fm { color:var(--f_med) !important; stroke:var(--f_med) !important; }
.fl { color:var(--f_low) !important; stroke:var(--f_low) !important; }
.f_inv { color:var(--f_inv) !important; stroke:var(--f_inv) !important; }
.bh { background:var(--b_high) !important; }
.bm { background:var(--b_med) !important; }
.bl { background:var(--b_low) !important; }
.b_inv { background:var(--b_inv) !important; }
.icon { color:var(--f_high) !important; stroke:var(--f_high) !important; }
    </style>
  </body>
</html>
